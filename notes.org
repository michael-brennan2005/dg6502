- Little endian, LSB then MSB.
  If two bytes are together, first 00 and then FF, the instruction is FF00.
- Opcodes are 8 bits, AAABBBCC
  AAA and CC define opcode.
  BB defines addressing mode.
  If the BB is an addressing mode that has some operand mode, then it can require 0, 1, or 2 extra bits. These are also stored in Little Endian.
- Same operation, different addressing mode is going to have the same top 3 bits and same bottom 2 bits.
- All of the addressing modes deal with operands except two: impl (operand implied) and rel (branch target)???
  So worry about those two, and then for everything else have a generic operand retrieval function! YAAAAAY!
- Do operand retrieval outside of function, inject it via arguments.
  - This potentially opens you up to a vulnerability with addressing. Not every instruction supports every addressing mode. Could add a validation, or leave it, doubtful any software would be broken cause of that.
- Addressing modes
    | Mode | Description                        |
    |------+------------------------------------|
    |  0x0 | Mix of impl, X ind, abs, #         |
    |  0x1 | All zpg                            |
    |  0x2 | Impl, #, A,                        |
    |  0x3 | All abs                            |
    |  0x4 | c=0 rel (all branching) c=1 ind, y |
    |  0x5 | Mix of zpgy and zpgx               |
    |  0x6 | Mix of impl and abs, y             |
    |  0x7 | All abs                            |
- Don't do operand retrieval outside of function. There is no consistency in these patterns. Do this stuff inside each opcode.
- Let's be repetitive now, and abstract later.
- What if instead... We put all the opcodes into a big ass table, and then have it so each instruction is just parsed?
  - 2D array with string values of everything "ORA (ind, x)", "AND abs,Y", etc.
  - When instruction comes in, get its high and low nibble, then lookup through 2d array. Do some quick string parsing (literally just split the string),
    then match address to an enum, and pass that enum result into operand getter. Match opcode to function, bing bang thank you ma'am.
  - Performance consideration, instead of string parsing, do some integer thing? I dont know if we need that level of perforamnce but IDK. keep that in mind
- ADC and SBC carry:
  - when addition result is 0 to 255, carry is cleared, otherwise carry is set.
  - when subtraction result is 0 to 255, carry is set, otherwise carry is cleared.
- ADC and SBC overflow:
  - When additon or subtraction is outside range -128 to 127, overflow is set, otherwise overflow is cleared.
